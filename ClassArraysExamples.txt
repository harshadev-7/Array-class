/*

https://www.geeksforgeeks.org/java/array-class-in-java/

compare(array 1, array 2) Method 

This method returns the difference as an integer lexicographically.


import java.util.Arrays;

public class compareArrays {
    public static void main(String[] args)
    {

        // Get the Array
        int intArr1[] = { 10, 20, 15, 22, 35 };

        // Get the second Array
        int intArr2[] = { 10, 15, 22 };

        // To compare both arrays
        System.out.println("Integer Arrays on comparison: " + Arrays.compare(intArr1, intArr2));
    }
}
*/



import java.util.Arrays;

public class ArrayComparison {
    public static void main(String[] args) {
        int[] arr1 = {1, 2, 3};
        int[] arr2 = {1, 2, 4};
        int[] arr3 = {1, 2, 3};
        int[] arr4 = {1, 2};

        // Comparing arr1 and arr2
        int result1 = Arrays.compare(arr1, arr2);
        System.out.println("arr1 vs arr2: " + result1); // Output: A negative integer (e.g., -1) because 3 < 4

        // Comparing arr1 and arr3
        int result2 = Arrays.compare(arr1, arr3);
        System.out.println("arr1 vs arr3: " + result2); // Output: 0 because they are equal

        // Comparing arr1 and arr4 (different lengths)
        int result3 = Arrays.compare(arr1, arr4);
        System.out.println("arr1 vs arr4: " + result3); // Output: A positive integer (e.g., 1) because arr1 is longer and equal up to arr4's length
    }
}


/*
https://www.geeksforgeeks.org/java/array-class-in-java/

The java.util.Arrays class: This is a utility class provided in the Java Collections Framework. It contains various static methods for manipulating arrays, such as:
Sorting: sort() methods for various data types (primitive and objects).
Searching: binarySearch() methods for sorted arrays.
Comparing: equals() methods to compare two arrays for equality.
Filling: fill() methods to assign a specific value to all elements of an array.
Converting to String: toString() to get a string representation of an array's contents.
Converting to List: asList() to view an array as a List.

*/

import java.util.Arrays;
import java.util.List;

public class AsListExample {
    public static void main(String[] args) {

	// with primitive arrays, it shows the memory reference of the array instead of the list contents
	int intArr[] = { 10, 20, 15, 22, 35 };
        // To convert the elements as List
        System.out.println("int array asList: " + Arrays.asList(intArr));
	System.out.println("int array toString: " + Arrays.toString(intArr));

        // Example with String array
        String[] colors = {"Red", "Green", "Blue"};
	System.out.println("Color asList: " + Arrays.asList(colors));

        List<String> colorList = Arrays.asList(colors);
        System.out.println("Color List: " + colorList);

        // Modifying an element in the list reflects in the array
        colorList.set(0, "Yellow");
        System.out.println("Modified Color List: " + colorList);
        System.out.println("Modified Colors Array: " + Arrays.toString(colors));

        // Example with Integer array (wrapper class)
        Integer[] numbers = {1, 2, 3, 4, 5};
        List<Integer> numberList = Arrays.asList(numbers);
        System.out.println("Number List: " + numberList);

        // Attempting to add/remove will throw UnsupportedOperationException
        try {
            numberList.add(6); // This will fail
        } catch (UnsupportedOperationException e) {
            System.out.println("Cannot add elements to a fixed-size list.");
        }

        // Example with primitive int array (demonstrates the single-element list behavior)
        int[] primitiveNumbers = {10, 20, 30};
        List<int[]> primitiveList = Arrays.asList(primitiveNumbers);
        System.out.println("Primitive List: " + primitiveList); // Output: [[I@... (a list containing one array object)
    }
}




/*

https://www.geeksforgeeks.org/java/array-class-in-java/

Built-in Arrays.binarySearch() method: Java's java.util.Arrays class provides overloaded static binarySearch() methods for various primitive types and objects. These methods offer a convenient way to perform binary search on sorted arrays.
Usage: Arrays.binarySearch(array, key) or Arrays.binarySearch(array, fromIndex, toIndex, key).
Return Value: If the key is found, its index is returned. If not found, it returns (-(insertion point) - 1), where the insertion point is the index where the key would be inserted to maintain the sorted order.

*/
import java.util.Arrays;

// Main class
public class binarySearchExample {

    // Main driver method
    public static void main(String[] args)
    {

        // Get the Array
        int intArr[] = { 10, 20, 15, 22, 35 };
	System.out.println("before sort, int array toString: " + Arrays.toString(intArr));

        Arrays.sort(intArr);
	System.out.println("after sort, int array toString: " + Arrays.toString(intArr));

        int intKey = 22;

        // Print the key and corresponding index, found
        System.out.println(intKey + " found at index = " + Arrays.binarySearch(intArr, intKey));

	intKey = 25;
        // Print the key and corresponding index, not found
        System.out.println(intKey + " found at index = " + Arrays.binarySearch(intArr, intKey));
    }
}

/*

import java.util.Arrays;

public class Main {
    public static void main(String[] args)
    {

        // Get the Array
        int intArr[] = { 10, 20, 15, 22, 35 };

        Arrays.sort(intArr);

        int intKey = 22;

        System.out.println(intKey + " found at index = " + Arrays.binarySearch(intArr, 1, 3, intKey));
    }
}

*/






/*

compare(array 1, array 2) Method 

This method returns the difference as an integer lexicographically.


import java.util.Arrays;

public class compareArrays {
    public static void main(String[] args)
    {

        // Get the Array
        int intArr1[] = { 10, 20, 15, 22, 35 };

        // Get the second Array
        int intArr2[] = { 10, 15, 22 };

        // To compare both arrays
        System.out.println("Integer Arrays on comparison: " + Arrays.compare(intArr1, intArr2));
    }
}
*/



import java.util.Arrays;

public class ArrayComparison {
    public static void main(String[] args) {
        int[] arr1 = {1, 2, 3};
        int[] arr2 = {1, 2, 4};
        int[] arr3 = {1, 2, 3};
        int[] arr4 = {1, 2};

        // Comparing arr1 and arr2
        int result1 = Arrays.compare(arr1, arr2);
        System.out.println("arr1 vs arr2: " + result1); // Output: A negative integer (e.g., -1) because 3 < 4

        // Comparing arr1 and arr3
        int result2 = Arrays.compare(arr1, arr3);
        System.out.println("arr1 vs arr3: " + result2); // Output: 0 because they are equal

        // Comparing arr1 and arr4 (different lengths)
        int result3 = Arrays.compare(arr1, arr4);
        System.out.println("arr1 vs arr4: " + result3); // Output: A positive integer (e.g., 1) because arr1 is longer and equal up to arr4's length
    }
}




/*

In Java, List is an interface within the Java Collections Framework, residing in the java.util package. It represents an ordered collection of elements where duplicates are allowed, and elements can be accessed by their numerical index (position).
Key Characteristics of Java Lists:
Ordered Collection: Elements maintain their insertion order, meaning the order in which they are added to the list.
Allows Duplicates: You can add the same element multiple times to a list.
Index-Based Access: Elements can be retrieved, modified, or removed using their zero-based index.
Dynamic Size: Unlike arrays, lists can dynamically grow or shrink as elements are added or removed.
Common Implementations of the List Interface:
Since List is an interface, you cannot directly instantiate it. Instead, you use classes that implement the List interface, providing concrete implementations of its methods. The most frequently used implementations include: 
ArrayList:
Based on a resizable array.
Offers fast random access (retrieving elements by index) due to its underlying array structure.
Generally efficient for adding elements to the end of the list and for retrieving elements.
Less efficient for insertions or deletions in the middle of the list, as it may require shifting elements.
LinkedList:
Implemented as a doubly linked list.
Efficient for insertions and deletions at any position, as it only involves updating pointers.
Less efficient for random access (retrieving elements by index) because it requires traversing the list from the beginning or end.
Vector:
Similar to ArrayList but is synchronized, meaning its methods are thread-safe.
Generally less commonly used in modern Java development due to performance overhead of synchronization and the availability of other concurrency utilities.
Stack:
Extends Vector and implements a Last-In, First-Out (LIFO) data structure.
Provides methods like push() to add elements and pop() to remove the top element.

*/
import java.util.ArrayList;
import java.util.List;

public class ListExample {
    public static void main(String[] args) {
        // Create an ArrayList of Strings
        List<String> fruits = new ArrayList<>();

        // Add elements to the list
        fruits.add("Apple");
        fruits.add("Banana");
        fruits.add("Orange");
        fruits.add("Apple"); // Duplicates are allowed

        // Access elements by index
        System.out.println("First fruit: " + fruits.get(0)); // Output: Apple

        // Modify an element
        fruits.set(1, "Grape");

        // Remove an element
        fruits.remove(2); // Removes "Orange"

        // Get the size of the list
        System.out.println("Number of fruits: " + fruits.size()); // Output: 3

        // Iterate through the list
        System.out.println("All fruits:");
        for (String fruit : fruits) {
            System.out.println(fruit);
        }
    }
}





/*


In Java, Vector is a legacy class found in the java.util package that implements a growable array of objects. It is part of the Java Collections Framework and provides a dynamic array functionality, similar to ArrayList.
Here are the key characteristics of Vector in Java:
Dynamic Array: Like ArrayList, Vector can grow or shrink in size as needed to accommodate adding or removing elements. It handles the underlying array resizing automatically.
Synchronized (Thread-Safe): A primary distinction of Vector is that its methods are synchronized, making it inherently thread-safe. This means that only one thread can access and modify a Vector instance at a time, preventing data corruption in multi-threaded environments. However, this synchronization comes with a performance overhead compared to ArrayList when thread safety is not a concern.
Implements List Interface: Vector implements the List interface, allowing it to utilize all the methods defined by the List interface for common operations like adding, removing, and accessing elements by index.
Legacy Methods: Vector includes some legacy methods that are not part of the standard Java Collections Framework, such as addElement(), elementAt(), and elements(). While still functional, it is generally recommended to use the standard List interface methods for better compatibility and consistency within the modern Java Collections API.
Capacity and Capacity Increment: Vector manages its storage by maintaining a capacity (the current allocated size of the internal array) and a capacityIncrement (the amount by which the capacity increases when the Vector needs to grow). This allows for some optimization in storage management.


*/


import java.util.Vector;

public class VectorExample {
    public static void main(String[] args) {
        // Create a Vector of Strings
        Vector<String> animals = new Vector<>();

        // Add elements
        animals.add("Dog");
        animals.add("Cat");
        animals.addElement("Horse"); // Using a legacy method

        System.out.println("Vector elements: " + animals);

        // Access elements
        String firstAnimal = animals.get(0);
        System.out.println("First animal: " + firstAnimal);

        // Remove elements
        animals.remove("Cat");
        System.out.println("Vector after removing Cat: " + animals);

	animals.add("Cow");
	System.out.println("Vector after adding Cow: " + animals);

	// Remove elements
        animals.remove(0);
        System.out.println("Vector after removing first element: " + animals);

        // Check size
        System.out.println("Vector size: " + animals.size());
    }
}


